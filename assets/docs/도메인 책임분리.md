

우리는 서버를 좀 더 빠르고 효과적으로 만들기 위해 노력한다.
트랜잭션 책임분리 또한 같다.


```

트랜잭션1에는 서비스1과 서비스2가 처리하는 상황이다.
Tx1{
Service1
Service2
}

service1은 Tx1이 속한 도메인에서 처리하지만, Service2는 서버가 나누어져있어서 따로 호출이 필요하다고 해보자.

이 service2가 트랜잭션1의 책임이라고 할 수 있을까?
Service2에 보낸 요청이 완료하는데까지 꼭 기다려야만 하는 걸까?

트랜잭션1의 책임은 Service1일 뿐, Service2에 대한 처리는 분리되어야 마땅할지 모른다.

그렇다면 어떻게 분리할 수 있을까?

Event로 처리하는 방법이 있을 수 있다.
트랜잭션1이 이벤트를 발행하면, 서비스2에게 요청이 가고, 서비스2에 대한 처리는 이제 더 이상 트랜잭션1에서 관리하지 않는 거다.

이렇게라면 트랜잭션의 책임 분리가 가능할 것 같다.
또, 서비스2에 대한 요청만 처리하고, 트랜잭션이 종료되니 속도가 개선된다(비동기 처리).

하지만, 아직 허점이 있다.
만약 서비스1이 서비스2에게 요청을 보낸 후에 실패한다면?
반대로 서비스2가 실패해서 트랜잭션이 롤백되어야한다면?

예를 들어,
결제와 재고처리를 담은 트랜잭션이 있다고 하자.
결제가 실패했는데 재고만 줄거나, 재고가 줄지 않았는데 결제만 된다면 비즈니스에 장애를 일으킬 수 있다.


실패 케이스에 대해서도 고려해줄 필요가 있다.


보상 트랜잭션, SAGA 패턴이 그 해결법이다.

```



이 모든 게 결국은 SOLID 원칙 중 SRP(Single Responsibility Principle). 단일 책임 원칙. 하나의 기능은 하나의 책임만을 갖는다.

하지만, 실세계에서는 그렇게 되기 힘든 경우들이 발생한다.
위에서 살펴본 쇼핑몰 아이템 구매 케이스처럼, 아이템을 구매하면, 결제만 하면 끝나는 게 아니라 재고 차감도 해줘야한다.

이럴 때 이벤트 처리는 단일책임원칙을 강제할 수 있도록 한다.

event 처리


3 layer에서는

Controller -> Service -> Repository -> Domain

Hexagonal Architecture



주문 -> 배치 -> 창고
만약 창고의 재고에 손상이 생겨 주문을 재할당해야한다면?

창고 -> 배치 -> 주문 서로 결합이 있다.

마찬가지로

좌석 예약 -> 예약 생성 -> 포인트 차감 끼리 결합이 있어서는 안된다

- All or Nothing은 맞음
- 시간 순으로 일치해야한다? 아님
  동시 생산(Connascence)


이 행위들을 이제 디커플링하자.
외부에 메세징 시스템을 두자.

메세징 시스템을 고를 때 메세지 순서, 실패 처리, 멱등성(idempotency) 등을 고려해야한다.


이벤트와 커맨드를 구분하자

pub/sub 구조. 핸들러.

내부이벤트와 외부 이벤트를 구분하자
외부로 나가는 이벤트는 검증을 적용하는 것이 중요하다.



시간적으로 결합되어 있는 상태인데, 시스템의 모든 부분이 동시에 제대로 작동할 때만 정상으로 작동하는 경우이다.

얼마나 빠르게 엉망진창이 되는지 확인할 수 있다.


- 이벤트와 커맨드라는 행동에 대한 추상화 개념을 통해서 적용한 규칙에 힘이 더 들어가는 것을 확인할 수 있다
- 유연하지만 강해졌다.

#### 읽기와 쓰기의 분리 (CQRS, Command and Query Responsibility Separation)

- 함수는 읽거나 쓰거나 둘 중에 하나만 해야한다.
  

도메인 모델의 초점은 보통 쓰기 연산을 위함
도메인 모델의 복잡도가 커질수록 모델을 구성하는 방법에 대한 선택의 폭이 넓어지고, 이에 따라 읽기 연산에 도메인 모델을 사용하는 게 더 어려워진다.
